articleid,title,volume,number,pages,month,year,refkey,note,remarks,references_,xxxreferences,fullxxxreferences,oldkey,abstract,preliminary
KleijnR82,"Corrigendum: Sequential, Continuous and Parallel Grammars",52,3,364,mar,1982,,,,KleijnR1981:221,,,,,
BergstraT82,The Completeness of the Algebraic Specification Methods for Computable Data Types,54,3,186--200,sep,1982,,,,"Sicomp::BergstraT1983, actai::GuttagH1978 ieeetse::LiskovZ1975, jcss::Wand1979, mfcs::WirsingB1980 mfcs::GiarratanaGM1976",,,,,
RivestS82,How to Reuse a ``Write-Once'' Memory,55,1--3,1--19,oct # ?/? # nov # ?/? # dec,1982,,,,,,,,,STOC::RivestS1982
NeuhoffS82,Channel Distances and Representation,55,1--3,238--264,oct # ?/? # nov # ?/? # dec,1982,,,,,,,,,
GolsonR83,Connections Between Two Theories of Concurrency: Metric Spaces and Synchronization Trees,57,2/3,102--124,may # ?/? # jun,1983,,,,"tcs::ArnoldN1980, IC::BakkerZ1982",,,,,
GianniniL84,Effectively Given Domains and Lambda-Calculus Models,62,1,36--63,jul,1984,,,,,,,,,
GoudaMY84,On the Progress of Communications between Two Finite State Machines,63,3,200--216,dec,1984,,,,,,,,,
GrantM85,Normalization and Axiomatization for Numerical Dependencies,65,1,1--17,apr,1985,,,,,,,,,
HartmanisIS85,Sparse Sets in {NP-P}: {EXPTIME} versus {NEXPTIME},65,2/3,158--181,may # ?/? # jun,1985,,,,,,,,,
AfratiPP85,The Complexity of Cubical Graphs,66,1/2,53--60,jul # ?/? # aug,1985,,,,,,,,,
Kutylowski87,A Generalized {Grzegorczyk} Hierarchy and Low Complexity Classes,72,2,133--149,feb,1987,,,,,,,,,
EngelfrietV87,Look-Ahead on Pushdowns,73,3,245--279,jun,1987,,,,,,,,,
Welch87,Simulating Synchronous Processors,74,2,159--170,aug,1987,,,,,,,,,
Bracha87,Asynchronous {Byzantine} Agreement Protocols,75,2,130--143,nov,1987,,,,,,,,,
EdelsbrunnerP88,Minimum Polygonal Separation,77,3,218--232,jun,1988,,,,,,,,,
SannellaT88,Specifications in an Arbitrary Institution,76,2/3,165--210,feb # ?/? # mar,1988,,,,,,,,"A formalism for constructing and using axiomatic specifications in an arbitrary logical system is presented.  This builds on the framework provided by Goguen and Burstall's work on the notion of an institution as a formalisation of the concept of a logical system for writing specifications.  We show how to introduce free variables into the sentences of an arbitrary institution and how to add quantifiers which bind them.  We use this foundation to define a set of primitive operations for building specifications in an arbitrary institution based loosely on those in the ASL kernel specification language.  We examine the set of operations which results when the definitions are instantiated in institutions of total and partial first-order logic and compare these with the operations found in existing specification languages.  We present proof rules which allow proofs to be conducted in specifications built using the operations we define.  Finally, we introduce a simple mechanism for defining and applying parameterised specifications and briefly discuss the program development process.",
LampsonB88,"Pebble, a Kernel Language for Modules and Abstract Data Types",76,2/3,278--346,feb # ?/? # mar,1988,,,,,,,,,
JouannaudK89,Automatic Proofs by Induction in Theories without Constructors,82,1,1--33,jul,1989,,,,,"BergstraK84, Dershowitz85",,,,
BertoniMS89,Membership Problems for Regular and Context-Free Trace Languages,82,2,135--150,aug,1989,,,,,,,,,
MontenyohlW89,Incorporating Static Analysis in a Combinator-Based Compiler,82,2,151--184,aug,1989,,,,,Wand83,,,"We show how restructuring a denotational definition leads to a more efficient compiling algorithm.  Three semantics-preserving transformations (static replacement, factoring, and combinator selection) are used to convert a continuation semantics into a formal description of a semantic analyzer and code generator.  The compiling algorithm derived below performs type checking before code generation so that type-checking instructions may be omitted from the target code.  The optimized code is proved correct with respect to the original definition of the source language.  The proof consists of showing that all transformations preserve the semantics of the source language.",
AndreD89,An Algebraic Characterization of Transition System Equivalences,82,2,198--229,aug,1989,,,,,,,,,
VitterL92,Learning in Parallel,96,2,179--202,feb,1992,,,,,"STOC::AjtaiB84, FOCS::BergerRS89, JACM::BlumerEHW89 Cook85, STOC::KearnsL88, STOC::KearnsLPV87",,,,
Breazu-TannenCGS91,Inheritance as Implicit Coercion,93,1,172--221,jul,1991,,,,,"Amadio91, Cardelli88, CoquandGW89, CoquandH88, Koymans82 Meyer82",,,,LICS::Breazu-TannenCGS1989:112
PassayT91,An Essay in Combinatory Dynamic Logic,93,2,263--332,aug,1991,,,,,Streett82,,,,
ChoH92,The Parallel Complexity of Finite-State Automata Problems,97,1,1--22,mar,1992,,,,,"Cook85, STOC::KarpUW85, FOCS::MeyerS72 STOC::StockmeyerM73",,,,
BurchCMDH92,Symbolic Model Checking: $10^{20}$ States and Beyond,98,2,142--170,jun,1992,,,,"MISC::BoseF1989, IEEETC::BrowneCDM1986 IEEETC::Bryant1986, IEEETC::Bryant1991, DAC::BurchCL1991 ICVLSI::BurchCL1991, DAC::BurchCMD1990, CTAP::ClarkeDK1990 TOPLAS::ClarkeES1986, TR::Cleaveland1989, AVMFSS::CoudertBM1989 LICS::EmersonL1986, ISCHDLA::FujitaF1989, CAV::Godefroid1990 LICS::GodefroidW1991, ICCD::KimuraC1990, TCS::Kozen1983 LP::MannaW1981, BOOK::Milner1980, TCS::Milner1983, TR::Park1974 CAV::ProbstL1990, TPSD::StirlingW1989, CATPN::Valmari1989 CAV::Valmari1990, ISFTC::YonedaNT1989",,,,"Many different methods have been devised for automatically verifying finite state systems by examining state-graph models of system behavior.  These methods all depend on decision procedures that explicitly represent the state space using a list or a table that grows in proportion to the number of states.  We describe a general method that represents the state space \emph{symbolically} instead of explicitly.  The generality of our method comes from using a dialect of the Mu-Calculus as the primary specification language.  We describe a \emph{model checking} algorithm for Mu-Calculus formulas that uses Bryant's \emph{Binary Decision Diagrams} (Bryant, R. E., 1986 \emph{IEEE Trans.\ Comput.}\ \textbf{C-35}) to represent relations and formulas.  We then show how our new Mu-Calculus model checking algorithm can be used to derive efficient decision procedures for CTL model checking, satisfiability of linear-time temporal logic formulas strong and weak observational equivalence of finite transition systems, and language containment for finite $\omega$-automata.  The fixed point computations for each decision procedure are sometimes complex, but can be concisely expressed in the Mu-Calculus.  We illustrate the practicality of our approach to symbolic model checking by discussing how it can be used to verify a simple synchronous pipeline circuit.",LICS::BurchCMDH1990:428
BenvenisteGSS92,A Denotational Theory of Synchronous Reactive Systems,99,2,192--230,aug,1992,,,,,"McNaughton66, FOCS::Muller63",,,,
Ristad93,The Anaphora Problem,105,1,105--131,jul,1993,C1011,,,"BOOK::Canny1988, LINGI::Chomsky1980, BOOK::Chomsky1981 BOOK::Chomsky1986, BOOK::Dudeney1967, BOOK::Emmet1972 BOOK::Fujimura1978, LINGI::Higginbotham1983, LINGI::Higginbotham1985 LINGA::Lasnik1976, JLINGR::Lasnik1981, MISC::Lasnik1989 FOCS::Reif1979:421, FOCS::ReifS1985:144, BOOK::Ristad1993",,,,"Consider the computational problem of understanding the utterances of a human language that contain pronouns.  In order to completely understand such utterances, the language user must determine the intended reference of each pronoun in a given utterance. For example, in order to comprehend the English sentence ``Jocasta loved her son,'' the hearer might determine that the possessive pronoun ``her'' and the proper noun ``Jocasta'' both refer to Jocasta the Queen of Thebes.  Using such facts of linguistic knowledge, we develop a sophisticated formal model of this computational problem and prove that it is NP-complete.  This result is the first empirically-plausible bound on the computational complexity of human language.  No knowledge of linguistic theory is needed to understand our analysis, only knowledge of English.",
LevcopoulosP94,Sorting Shuffled Monotone Sequences,112,1,37--50,jul,1994,C1074,,,,Estivill-CastroW89,,,"We present a new sorting algorithm that adapts to existing order within the input sequence. Let $k$ be the smallest integer such that a sequence~$X$ of length~$n$ can be reduced to the empty sequence by the removal of $k$~monotone, increasing or decreasing subsequences.  The algorithm, Slabsort, sorts~$X$ in $O(n\log k)$ time, without knowing~$k$ beforehand, which is optimal in a comparison-based model.",
Pierce94,Bounded Quantification is Undecidable,112,1,131--165,jul,1994,C1330,,,,"Breazu-TannenCGS91, BruceL90, Cardelli88, Mitchell88",,,"$F_\leq$ is a typed $\lambda$-calculus with subtyping and bounded second-order polymorphism.  First introduced by Cardelli and Wegner, it has been widely studied as a core calculus for type systems with subtyping. \par Curien and Ghelli proved the partial correctness of a recursive procedure for computing minimal types of $F_\leq$ terms and showed that the termination of this procedure is equivalent to the termination of its major component, a procedure for checking the subtype relation between $F_\leq$ types.  This procedure was thought to terminate on all inputs, but the discovery of a subtle bug in a purported proof of this claim recently reopened the question of the decidability of subtyping, and hence of typechecking. \par This question is settled here in the negative, using a reduction from the halting problem for two-counter Turing machines to show that the subtype relation of $F_\leq$ is undecidable.",
ComonD94,Equational Formulae with Membership Constraints,112,2,167--216,1~} # aug,1994,C1204,,,,"LICS::GoguenM87, LICS::JouannaudK86, LICS::Maher88 LICS::Mosses89a, Plaisted85",,,"We propose a set of transformation rules for first order formulae whose atoms are either equations between terms or ``membership constraints'' $t\in\zeta$. $\zeta$ can be interpreted as a regular tree language ($\zeta$ is called a {\em sort\/} in the algebraic specification community) or as a tree language in any class of languages which satisfies some adequate closure and decidability properties.  This set of rules is proved to be correct, terminating and complete. This provides a quantifier elimination procedure: for every regular tree language $\cal L$, the first order theory of some structure defining $\cal L$ is decidable.  This extends former results of (Mal'cev 62, Maher 88, Comon and Lescanne 89).  We also show how to apply our results to automatic inductive proofs in equational theories.",
HenzingerMP94,Temporal Proof Methodologies for Timed Transition Systems,112,2,273--337,1~} # aug,1994,C1487,,,,"LICS::AlurH90, LICS::AbadiL88, LICS::HarelLP90 KoymansSRGA88, FOCS::Pnueli77",,,"We extend the specification language of temporal logic, the corresponding verification framework, and the underlying computational model to deal with real-time properties of reactive systems.  The abstract notion of timed transition systems generalizes traditional transition systems conservatively: qualitative fairness requirements are replaced (and superseded) by quantitative lower-bound and upper-bound timing constraints on transitions.  This framework can model real-time systems that communicate either through shared variables or by message passing and real-time issues such as timeouts process priorities (interrupts), and process scheduling. \par We exhibit two styles for the specification of real-time systems. While the first approach uses time-bounded versions of the temporal operators, the second approach allows explicit references to time through a special clock variable.  Corresponding to the two styles of specification, we present and compare two different proof methodologies for the verification of timing requirements that are expressed in these styles.  For the {\em bounded-operator\/} style, we provide a set of proof rules for establishing bounded-invariance and bounded-response properties of timed transition systems.  This approach generalizes the standard temporal proof rules for verifying invariance and response properties conservatively.  For the {\em explicit-clock\/} style, we exploit the observation that every time-bounded property is a safety property and use the standard temporal proof rules for establishing safety properties.",
HausslerLW94,"Predicting $\{0,1\}$-Functions on Randomly Drawn Points",115,2,248--292,dec,1994,C1175,,,,"FOCS::Blum90a, JACM::BlumerEHW89, EhrenfeuchtH89 EhrenfeuchtHKV89, Haussler92, HausslerKLW91, JACM::KearnsLV94 JACM::KearnsV94, LittlestoneW94, STOC::Natarajan87, JACM::PittV88",,,"We consider the problem of predicting $\{0,1\}$-valued functions on ${\bf R}^n$ and smaller domains, based on their values on randomly drawn points.  Our model is related to Valiant's PAC learning model, but does not require the hypotheses used for prediction to be represented in any specified form.  In our main result we show how to construct prediction strategies that are optimal to within a constant factor for any reasonable class~$F$ of target functions.  This result is based on new combinatorial results about classes of functions of finite VC dimension.  We also discuss more computationally efficient algorithms for predicting indicator functions of axis-parallel rectangles, more general intersection closed concept classes, and halfspaces in ${\bf R}^n$.  These are also optimal to within a constant factor.  Finally, we compare the general performance of prediction strategies derived by our method to those derived from methods in PAC learning theory.",
NerodeNS95,Computing Circumscriptive Databases: {I}. Theory and Algorithms,116,1,58--80,jan,1995,C1302,,,"IEEECS::AstromBCCLV1991, TR::AraqueC1991 PODS::BancilhonMSU1986, SIGMOD::BancilhonR1986, PODS::BeeriR1987 TR::BellNNS1991, PODS::BellNNS1992, COR::BlairJL1988 AAAI::CadoliL1990, IEEECDC::CainesW1991, JACM::ChandruH1991:205 STOC::CosmadakisGKV1988, TCS::EiterG1993:231, MISC::EmeryNS1992 COMPI::EtheringtonMR1985, BOOK::Etherington1988 ICSLP::GelfondL1988:1070, ICSLP::GelfondL1988:579 ARTII::Ginsberg1989, BOOK::Hailperin1976, BOOK::HillierL1974 ANNMAI::HookerF1990, POPL::JaffarL1987, DSS::Jeroslow1988 COMB::Karmarkar1984, DOKAN::Khachian1979, ILPS::KempSS1991 CACM::Kohn1991:64, SCACSD::KohnN1992, JACM::KolaitisP1990:1 IPL::Krishnaprasad1988, IJCAI::Lifschitz1985, ARTII::Lifschitz1985 AAAI::Lifschitz1986, ANNMAI::MarekNR1990, ARTII::McCarthy1980 ARTII::McCarthy1986, ARTII::MinkerP1986, ARTII::Moore1985 ICLP::MorrisUG1986, AAAI::Przymusinski1986, ACMTDS::Roussopoulos1991 APAL::Schlipf1987, PODS::ShmueliTZ1988, PODS::Ullman1989",,,,"Though circumscription was introduced by McCarthy over a decade ago, there has been relatively little work on algorithms for computing circumscriptive databases.  In this paper, we develop algorithms to compute the preferred models of circumscriptive databases at compile-time using mixed integer linear programming techniques.  Two advantages of this (bottom-up) approach are that it makes efficient re-use of previous computations and it provides much faster run-time performance.  Some other advantages of using linear programming to automate deduction at compile time is that its re-optimization facilities elegantly accommodate database updates and also that it leads to a completely declarative formulation in which ordering of rules and literals in rule bodies plays no real role. Finally, we plan to use a standard relational database system as our run-time environment; this should yield relatively fast run-time processing, and provide a more expressive query language in which aggregates and the like can be expressed easily.",
KucherovT95,Decidability of Regularity and Related Properties of Ground Normal Form Languages,118,1,91--100,apr,1995,C1406,,,,Plaisted85,,,"We study language-theoretical properties of the set of reducible ground terms and its complement - the set of ground normal forms induced by a given rewriting system.  As a tool for our analysis we introduce the property of finite irreducibility of a term with respect to a variable and prove it to be decidable. It turns out that this property generalizes numerous interesting properties of the language of ground normal forms. In particular, we show that testing regularity of this language can be reduced to verifying this property. In this way we prove the decidability of the regularity of the set of ground normal forms, the problem mentioned in the list of open problems in rewriting (Dershowitz, Jouannaud, and Klop, 1991). Also the decidability of the existence of an equivalent ground term rewriting system and some other results are proved.",
ChenT95,The Complexity of Selecting Maximal Solutions,119,2,231--239,jun,1995,C1514,,,,"STOC::Anderson85, STOC::KarpW84, STOC::Luby85 STOC::MulmuleyVV87, FOCS::Papadimitriou91, FOCS::PapadimitriouW85",,,"Many important computational problems involve finding a maximal (with respect to set inclusion) solution in some combinatorial context.  We study such maximality problems from the complexity point of view, and categorize their complexity precisely in terms of tight upper and lower bounds. Our results give characterizations of coNP D$^{\rm P}$, $\Pi^{\rm P}_2$, FP$^{\rm NP}_{\parallel}$ FNP/\hspace{-1mm}/OptP$[\log n]$ and FP$^{\Sigma^{\rm P}_2}_{\parallel}$ in terms of subclasses of maximality problems.  An important consequence of our results is that finding an $X$-minimal satisfying truth assignment for a given CNF boolean formula is complete for FNP/\hspace{-1mm}/OptP$[\log n]$, solving an open question by Papadimitriou [{\em Proceedings of the 32nd IEEE Symposium on the Foundations of Computer Science}, 1991, pp.~163--169].",
BookLM95,The Global Power of Additional Queries to Random Oracles,120,1,49--54,jul,1995,C1526,,,,"JACM::Chaitin75, Martin-Lof66",,,"It is shown that, for every $k\geq0$ and every fixed algorithmically random language $B$, there is a language that is polynomial-time, truth-table reducible in $k+1$ queries to $B$ but not truth-table reducible in $k$ queries in {\em any\/} amount of time to {\em any\/} algorithmically random language $C$.  In particular, this yields the separation $\mbox{P$_{k\mbox{-}tt}$} ({\rm RAND}) \subsetneqq \mbox{P$_{(k+1)\mbox{-}tt}$}({\rm RAND})$, where RAND is the set of all algorithmically random languages.",
Neraud95,Algorithms for Detecting Morphic Images of a Word,120,1,126--148,jul,1995,C1506,,,,Ukkonen85,,,"Let $\Delta$ and $\Sigma$ be two disjoint finite alphabets. Given a ``pattern'' $R \in (\Delta\cup\Sigma)^*$, and a ``text'' $w \in \Sigma^*$, we consider the problem that consists in deciding whether there exists a morphism $\phi : (\Delta\cup\Sigma)^*\rightarrow \Sigma^*$, with $\phi(a)=a$ for every constant $a\in \Sigma$, and such that $\phi(R)$ is a factor of $w$. In the general case, this is a NP-complete problem (Angluin, 1980). We study the two following restrictions: (a)~$R$ is an arbitrary one-variable pattern with constants (elements in $\Sigma$); (b)~$R$ is a two-variable pattern without constant.  In the first case, we show that the problem may be solved by an $O(|w|^2\ln |w|)$-time algorithm. In the case we present a $O(|w|^2\ln^{2}|w|)$-time algorithm for solving the question.",
AdlemanHK95,Efficient Checkers for Number-Theoretic Computations,121,1,93--102,15~} # aug,1995,C1109,,,,"FOCS::BeigelBFG91, STOC::BlumK89, STOC::BlumLR90 STOC::GemmellLRSW91, STOC::Yao90",,,"Manuel Blum has recently proposed a new approach to the problem of program correctness, the {\em program checker}.  Here, {\em efficient\/} program checkers are presented for two important number theory problems, integer GCD and modular exponentiation.  The former result answers an open problem posed by Blum.  The latter result paves the way for more robust cryptographic programs, as modular exponentiation is the basis for several cryptosystems.  Taken together, these results lay the foundation for more reliable number-theoretic programs.",
CeceFI96,Unreliable Channels Are Easier to Verify Than Perfect Channels,124,1,20--31,10~} # jan,1996,C1630; PN2524,,,"LICS::AbdullaJ1993, ICALP::AbdullaJ1994 CACM::BartlettSW1969, BOOK::Berstel1979, COMPNET::Bochmann1978 JACM::BrandZ1983, MISC::CCITT1988, BOOK::DiazAC1989 JACM::EmersonH1986, DC::Finkel1994, TCS::GlabbeekV1993 CAI::GoudaGLR1987, PLMS::Higman1952, BOOK::Lothaire1983 PSTV::Pachl1987, TOPLAS::PengP1991, PJMATH::Tarski1955",,,,"We consider the problem of verifying correctness of finite state machines that communicate with each other over unbounded FIFO channels that are unreliable.  Various problems of interest in verification of FIFO channels that can lose messages have been considered by Finkel~(1994), and by Abdulla and Jonsson~(1993, 1994). We consider, in this paper, other possible unreliable behaviors of communication channels, viz.  (a) duplication and (b) insertion errors.  Furthermore, we also consider various combinations of duplication, insertion and lossiness errors.  Finite state machines that communicate over unbounded FIFO buffers is a model of computation that forms the backbone of ISO standard protocol specification languages Estelle and SDL.  While an assumption of a perfect communication medium is reasonable at the higher levels of the OSI protocol stack, the lower levels have to deal with an unreliable communication medium; hence our motivation for the present work.  The verification problems that are of interest are {\em reachability {\em unboundedness}, {\em deadlock}, and {\em model-checking against CTL*}.  All of these problems are undecidable for machines communicating over reliable unbounded FIFO channels.  So, it is perhaps surprising that some of these problems become decidable when unreliable channels are modeled.  The contributions of this paper are: (a)~An investigation of solutions to these problems for machines with insertion errors, duplication errors, or a combination of duplication insertion and lossiness errors, and (b)~A comparison of the relative expressive power of the various errors.",
FraserIM96,Maximal Common Subsequences and Minimal Common Supersequences,124,2,145--153,1~} # feb,1996,C1660; PN2533,,,"FOCS::AroraLMSS1992:14, BOOK::GareyJ1979 IPL::Halldorsson1993:169, JACM::Maier1978:322 KIBER::Timkovskii1989:1, MISC::JiangL1992, ALGOR::ApostolicoG1987:316 CACM::Hirschberg1975:341, JACM::Hirschberg1977:664 CACM::HuntS1977:350, ALGOR::Myers1986:251 JCSS::PapadimitriouY1991:425, IC::Ukkonen1985:100, IPL::WuMMM1990:317 IPL::Irving1991:197, SIDMA::YannakakisG1980:364, TCS::RaihaU1981:187 THESIS::Middendorf1992",,,,"The problems of finding a longest common subsequence and a shortest common supersequence of a set of strings are well-known. They can be solved in polynomial time for two strings (in fact the problems are dual in this case), or for any fixed number of strings, by dynamic programming. But both problems are NP-hard in general for an arbitrary number $k$ of strings.  Here we study the related problems of finding a shortest maximal common subsequence and a longest minimal common supersequence. We describe dynamic programming algorithms for the case of two strings (for which case the problems are no longer dual), which can be extended to any fixed number of strings.  We also show that both problems are NP-hard in general for $k$ strings, although the latter problem, unlike shortest common supersequence, is solvable in polynomial time for strings of length 2.  Finally, we prove a strong negative approximability result for the shortest maximal common subsequence problem.",
Chaudhuri96,Sensitive Functions and Approximate Problems,126,2,161--168,1~} # may,1996,C1529,,,"SICOMP::Azar1992, IC::Beame1988, JACM::BeameH1989 FOCS::Chaudhuri1993, SICOMP::CookDR1986, SODA::Hagerup1993 FOCS::HagerupR1992, JACM::LiY1989, SODA::MacKenzie1992 STOC::MatiasV1991, SICOMP::Nisan1991, SICOMP::VishkinW1985 ALGOR::FichRW1988",,,,"Properties of functions that are good measures of the CRCW PRAM complexity of computing them are investigated.  While the \emph{block sensitivity} is known to be a good measure of the CREW PRAM complexity, no such measure is know for CRCW PRAMs.  It is shown that the complexity of computing a function is related to its \emph{everywhere sensitivity}, introduced by Vishkin and Wigderson. Specifically, the time required to compute a function $f: D^n \mapsto R$ of everywhere sensitivity $\mathit{es}(f)$ with $P$~processors and unbounded memory is $\Theta(\log [\log \mathit{es}(f)/(\log(|D| + 4P/\mathit{es}(f)))])$.  This improves the results of Azar and of Vishkin and Wigderson.  This lower bound is used to derive new lower bounds for some \emph{approximate problems}.  These problems can often be solved faster than their exact counterparts and for many applications, it is sufficient to solve the approximation problem.  It is shown that \emph{approximate selection}, \emph{approximate counting}, \emph{approximate compaction}, and \emph{padded sorting all require time $\Theta(\log \log n)$ with a linear number of processors, if the level of accuracy desired is moderately high.  For these levels of accuracy, no lower bounds are known for these problems on the PRAM model.  The lower bounds for some of the problems are tight.",
FairtloughM1997,Propositional Lax Logic,137,1,1--33,25~} # aug,1997,C1747; PN2627,,,"jsyml::Curry1952, jsyml::Ewald1986, jsyml::GabbayD1974 ndjfl::MiglioliMOQU1989, ic::Moggi1991",,,,"We investigate a peculiar intuitionistic modal logic, called Propositional Lax Logic (PLL), which has promising applications to the formal verification of computer hardware.  The logic has emerged from an attempt to express correctness up to behavioural constraints---a central notion in hardware verification---as a logical modality.  As a modal logic it is special since it features a single modal operator~$\bigcirc$ that has a flavour both of possibility and of necessity.  In the paper we provide the motivation for PLL and present several technical results.  We investigate some of its proof-theoretic properties, presenting a cut-elimination theorem for a standard Gentzen-style sequent presentation of the logic.  We go on to define a new class of fallible two-frame Kripke models for~PLL\@.  These models are unusual since they feature worlds with inconsistent information; furthermore, the only frame condition imposed is that the $\bigcirc$-frame be a subrelation of the $\supset$-frame.  We give a natural translation of these models into Goldblatt's $\mathcal{J}$-space models of~PLL\@.  Our completeness theorem for these models yields a G\?odel-style embedding of PLL into a classical bimodal theory of type~(S4, S4) and underpins a simple proof of the finite model property.  We proceed to prove soundness and completeness of several theories for specialized classes of models.  We conclude with a brief exploration of two concrete and rather natural types of model from hardware verification for which the modality~$\bigcirc$ models correctness up to timing constraints.  We obtain decidability of $\bigcirc$-free fragment of the logic of the first type of model which coincides with the stable form of Maksimova's intermediate logic~$L/7$.",
SegalaGSL1998,Liveness in Timed and Untimed Systems,141,2,119--171,15~} # mar,1998,C1822; PN2671,,,"tcs::AbadiL1991:253, toplas::AbadiL1993:73 toplas::AbadiL1994:1543, ipl::AlpernS1985:181, tcs::NicolaH1984:83 toplas::Lamport1994:872, ic::LynchS1989:81, ic::LynchV1995:214 ic::LynchV1996:1, ipl::RomijnV1996:245",,,,"When proving the correctness of algorithms in distributed systems, one generally considers \emph{safety} conditions and \emph{liveness} conditions.  The Input/Output (I/O) automaton model and its timed version have been used successfully, but have focused on safety conditions and on a restricted form of liveness called fairness.  In this paper we develop a new I/O automaton model, and a new timed I/O automaton model, that permit the verification of general liveness properties on the basis of existing verification techniques. Our models include a notion of \emph{receptiveness} which extends the idea of \emph{receptiveness} of other existing formalisms, and enables the use of compositional verification techniques.  The presentation includes an \emph{embedding} of the untimed model into the timed model which preserves all the interesting attributes of the untimed model. Thus, our models constitute a \emph{coordinated framework} for the description of concurrent and distributed systems satisfying general liveness properties.",
