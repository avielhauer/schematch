citkey,txt
Ache00a,Piccola is a language for composing applications from software components. It has a small syntax and a minimal set of features needed for specifying different styles of software composition. The core features of Piccola are communicating agents which perform computations and forms which are the communicated values. Forms are a special notion of extensible immutable records. Forms and agents allow us to unify components static and dynamic contexts and arguments for invoking services. Through a series of examples we present a tour of Piccola illustrating how forms and agents suffice to express a variety of compositional abstractions and styles.
Bour94a,By means of an illustrative application we discuss the implementation choices of the rule-based coordination language LO . Distributed applications written in LO manifest two levels of granularity each with their specific communication paradigm. At the finer level individual objects are composed into agents and communicate through blackboards. At the coarser level these agents interact through broadcasts. This dichotomy determines implementation choices:  Concurrency among agents naturally maps onto distributed processes (with e.g. RPC) whereas concurrency among objects maps onto threads (in shared memory). These four abstractions (objects blackboards agents and broadcasts) together with LO 's basic computation paradigm (rules) are implemented as a class-based run-time library thereby enriching classical object-oriented platforms.  Finally we stress the fact that the resulting run-time library is poly- morphic:  The run-time can manipulate any independently defined appli- cation object provided its class respects a minimal protocol. Run-time polymorphism has turned out to be the key to composition-based reuse.
Foot94a,Reusable objects are the result of an iterative evolutionary process. This evolution proceeds as designers refactor their designs to address hanging requirments and improve the structural integrity and reusability of their designs. As objects mature relationships based on aggregation replace casual inheritance.
Hors90a,Abstract interpretation is a technique that has been applied to Prolog code for the purposes of mode analysis and determinacy analysis. This paper shows how it may also be used to discover which Prolog objects are lists. One use of such an analysis would be for program verification purposes. A second use would be for optimizing memory allocation especially if cdr-coding is used to implement lists.
Nier91b,We argue that object-oriented programming is only half of the story.  Flexible configurable applications can be viewed as collections of reusable objects conforming to standard interfaces together with scripts that bind these objects together to perform certain tasks. Scripting encourages a component-oriented approach to application development in which frameworks of reusable components (objects and scripts) are carefully engineered in an evolutionary software life-cycle with the ultimate goal of supporting application construction largely from these interchangeable prefabricated components. The activity of constructing the running application is supported by a visual scripting tool that replaces the textual paradigm of programming with a visual paradigm of direct manipulation and editing of both application and user interface components. We present scripting by means of some simple examples and we describe a prototype of a visual scripting tool called Vista.  We conclude with some observations on the environmental support needed to support a component-oriented software life-cycle using as a specific example the application de velopment environment of ITHACA a large European project of which Vista is a part.
Papa91a,The design of programming languages that cleanly integrate obc constructs and object-oriented features that promote software reuse is an open problem. We describe a design space that characterizes approaches to object-oriented obc in terms of a number of language design choices concerning the relationship between objects and obc. We identify requirements for software reuse and with the help of an example that illustrates several of these requirements explore the design space in order to evaluate which design choices interfere with reuse and which appear to adequately support it. We conclude by highlighting open research issues which we believe are essential for achieving effective reuse of concurrent software.
Pint92a,This paper presents gluons as objects that mediate software component cooperation. We discuss the advantages of encapsulating inter-component interaction inside a set of special objects. We present the design of a hierarchy of gluon classes that provide the support for the application domain independent part of component interaction protocols. As an example we present the design of a financial information framework and we discuss the role that gluons play in the definition of the framework.
Tsic87c,Most object-oriented systems lack two useful facilities: the ability of objects to migrate to new environments and the ability of objects to acquire new operations dynamically. This paper proposes Knos an object-oriented environment which supports these actions. Their operations data structures and communication mechanisms are discussed. Kno objects learn by exporting and importing new or modified operations. The use of such objects as intellectual support tools is outlined. In particular various applications involving co-operation negotiation and apprenticeship among objects are described.
