,,,,,,,,,,
0,33507565,715650,2,64679460,Comment,SaurabhJinturkar,2016-07-28 23:55:47.640,,0,"Do you see any performance impact of doing this way where Dog(d) is copy constructor?

`List<Dog> clonedDogs = new ArrayList<>();

dogs.stream().parallel().forEach(d -> clonedDogs.add(new Dog(d)));`"
1,33507565,715650,2,64706119,Comment,Lii,2016-07-29 15:36:52.127,,1,"@SaurabhJinturkar: Your version is not thread-safe and should not be used with parallel streams. That is because the `parallel` call makes `clonedDogs.add` get called from multiple threads at the same time. The versions which uses `collect` are thread-safe. This is one of the advantages of the functional model of the stream library, the same code can be used for parallel streams."
2,33507565,715650,2,64706194,Comment,Lii,2016-07-29 15:39:19.390,,1,"@SaurabhJinturkar: Also, the collect operation is fast. It does pretty much the same thing as your version does, but also work for parallel streams. You could fix your version by using, for example, a concurrent queue instead of an array list, but I'm almost certain that would be much slower."
3,33507565,715650,2,65554558,Comment,Gustavo,2016-08-23 14:25:49.520,,0,Whenever I try to use your solution I get an `Unhandled exception type CloneNotSupportedException` on `d.clone()`. Declaring the exception or catching it doesn't solve it.
4,33507565,715650,2,65556398,Comment,Lii,2016-08-23 15:06:39.377,,0,"@Gustavo: That is almost certainly because the object you are cloning, (`Dog` in this example) does not support cloning. Are you sure it implements the `Clonable` interface?"
5,33507565,715650,2,65556841,Comment,Gustavo,2016-08-23 15:16:09.600,,0,@Lii It does. Plus it overrides `clone()`. I had to change my `clone()` not to throw any exceptions.
6,33507565,715650,2,65557457,Comment,Lii,2016-08-23 15:31:17.940,,0,"@Gustavo: Ah, now I understand, I thought you got an exception at runtime but you got a compilation error. Yes, alas, it is very inconvenient to work with checked exceptions together with streams and lambdas. I believe it is okay in this case however, because I think the best practice when overriding `clone` is to do what you did and not declare the exception (since you don't plan on throwing it anyway). I'll add a note about that to the answer. Thanks!"
7,33507565,715650,2,73976430,Comment,Yogen Rai,2017-04-17 21:51:06.690,,0,"@Lii As stream is functional in nature, meaning `an operation on a stream produces a result, but does not modify its source.`, to my understanding, we do not need to use map. So, we can directly use,
`List<Dog> clonedList = dogs.stream().collect(Collectors.toList());`
[Oracle Doc](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)"
8,33507565,715650,2,73989677,Comment,Lii,2017-04-18 08:32:04.433,,0,"@YogenRai: No, this is not the case. Your line of code would give a shallow copy of the list; the result would be new list, but it would contain the same `Dog` objects. The ""*source list*"" would not be modified, but any future modification of the content dogs would modify the same dogs as in the source. This question is about creating *new dog objects* in a new list. This is what is called a *deep copy*."
9,33507565,715650,2,74004641,Comment,Yogen Rai,2017-04-18 14:22:01.570,,0,"@Lii Ya you are right :) I didn't notice that change in any of element in `dogs` and vice versa with cloned list will be reflected on both of them. And, as others pointed out, I think copy constructor would be the best option to create new copy. So, our lamda would be `List<Dog> clonedList = dogs.stream().map(Dog::new).collect(Collectors.toList());` and I have copy constructor there in `Dog` class. But anyway, thanks"
10,33507565,715650,2,74041819,Comment,Lii,2017-04-19 10:57:57.033,,0,"@YogenRai: You're right, it's better with a copy constructors. I'll add that to the answer."
